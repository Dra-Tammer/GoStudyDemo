#### 数据结构课程设计

一开始是想用rand函数随机生成一个矩阵，发现有马鞍点的概率太小了，所以改为键盘输入一个矩阵

先找出每一行中最大的那一个，记住它的下标，假设它是最大值，再比较该列，只有有比他大的，循环结束，找下一行的最小值。如没有比他大的，将其添加进马鞍点切片中。

 生成随机数的rand.Intn(max - min) + min

#### scanf

可以看到，我们只成功输入了bob这一个数据，有一个错误叫unexpected newline，这个错误其实就是我们输入的回车，因为scanf函数遇到scanf就结束，从缓冲区依次读取以空格分开的数据；对我们这个程序而言，首先按%s读入了bob，然后再按%d读取下一个数据（回车），但是回车键不是十进制整形数据，它按%d怎么可能读得进去呢，所以就出现了只成功读取一个数据，报错为 “没有意料到的新行”
[(13条消息) GO语言输入函数--关于scanf、scan、scanln函数使用过程中的一些坑_♂Mercury的博客-CSDN博客_go scanf](https://blog.csdn.net/qq_52698632/article/details/113747479)

scanf：按照给定的格式依次读取数据（包括非法数据），不能换行输入（如果要换行需要在前面加一个scanln吸收掉回车符，就像c语言中的getchar）
scan：比scanf高级，依次读取数据，遇到回车会忽略，可以换行输入（如果要先用了scan输入，再用scanf输入的话，需要在中间加一个scanln）
scanln：类似scan，但是遇到换行（回车）立马结束输入，如果要换行输入必须用多个scanln

#### slice

大家都知道切片是指向底层数组的指针，切片本身不存储任何数据。这意味着即使在这里按值传递切片，函数中的切片仍指向相同的内存地址。所以在`reverse()`内部使用的切片是一个不同的指针对象，但仍将指向相同的内存地址，共享相同的数组。所以在函数调用之后，该数组中的数字重新排列，函数外部的切片与内部的切片共享着相同的底层数组，所以外部的 `s` 表现出来的就是它也被排序了。

#### 快速排序

1. 选定pivot中心轴
2. 将大于pivot的数字放在pivot的右边
3. 将小于pivot的数字放在pivot的左边
4. 分别对左右子序列重复前三步数操作

归并排序使用了分治和递归的思想

